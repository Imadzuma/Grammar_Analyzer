# Исследование в области синтаксичекских анализаторов. LL(k) анализаторы

Выполнила: Мезина Маргарита, студентка группы 381608 ННГУ им. Лобачевского  
Специально для Netcracker - задание 4

### Цель работы:
1. Проведение исследования в области нисходящих анализаторов грамматики LL(k) с целью получения навыков исследований в области построения современных операционных систем и языка программирования С99.
2. Реализация алгоритма LL(1) анализатора с целью демонстрации полученных навыков и умений.

### План исследования:

1. Теоретическая часть  
1.1. Определение формальной грамматики  
1.2. Синтаксический анализ и и иерархия анализаторов  
1.3. КС-грамматика и МП-автоматы  
1.4. LL(k)-грамматика  
1.5. Множества FIRST и FOLLOW  
1.6. LL(1)-грамматика  
1.7. Необходимое условие для LL(1) грамматики
2. Практическая часть  
2.1. Постановка задачи  
2.2. Структура программы  
2.3. Описание работы программы  
2.4. Алгоритм построения множества FIRST(A)  
2.5. Алгоритм построения множества FOLLOW(A)  
2.6. Алгоритм конструирования таблицы предсказывающего анализатора  
2.7. Алгоритм «сдвиг-свертка» для LL(1)-грамматик  
2.8. Результаты работы программы  
2.9. Возможные пути для оптимизации  
3. Результаты исследования

## Теоретическая часть

#### Определение формальной грамматики
**Формальная грамматика** – это математическая система, определяющая язык посредством порождающих правил.
Определение Формальной грамматикой называется четверка вида: `G=(Vt, Vn, P, S)`, где:
* `Vn` - конечное множество нетерминальных символов;
* `Vt` - множество терминальных символов грамматики;
* `Р` – множество правил вывода грамматики, являющееся конечным подмножеством множества `(Vt∪Vn)+ x (Vt∪Vn)*` элемент `(a, b)` множества `Р` называется правилом вывода и записывается в виде `a → b `(читается: «из цепочки `a` выводится цепочка `b`»);
* `S` - начальный символ грамматики, `S∈Vn`.

#### Синтаксический анализ и и иерархия анализаторов

**Cинтаксический анализ** (или разбор, жарг. парсинг ← англ. parsing) в лингвистике и информатике — процесс сопоставления линейной последовательности лексем (слов, токенов) естественного или формального языка с его формальной грамматикой. Результатом обычно является дерево разбора (синтаксическоедерево).

**Синтаксический анализатор** (жарг. парсер ← англ. parser) — это программа или часть программы, выполняющая синтаксический анализ.  
Задача синтаксического анализатора - провести разбор текста программы, сопоставив его с эталоном, данным в описании языка. Для синтаксического разбора используются контекстно-свободные грамматики (КС-грамматики).  
Вход синтаксического анализатора – последовательность лексических и таблицы, например, таблица внешних представлений, которые являются выходом лексического анализатора.  
Выход синтаксического анализатора – дерево разбора и таблицы, например, таблица идентификаторов и таблица типов, которые являются входом для следующего просмотра компилятора (например, это может быть просмотр, осуществляющий контроль типов). 

**Нисходящий парсер** (англ. top-down parser) — продукции грамматики раскрываются, начиная со стартового символа, до получения требуемой последовательности токенов.  
* Метод рекурсивного спуска  
* LL-анализатор  
  
**Восходящий парсер** (англ. bottom-up parser) — продукции восстанавливаются из правых частей, начиная с токенов и кончая стартовым символом.  
  •	LR-анализатор  
  •	GLR-анализатор
  
#### КС-грамматика и МП-автоматы

Грамматика `G=(Vt, Vn, P, S)` называется **контекстно-свободной грамматикой (КС-грамматикой)**, если ее правила вывода имеют вид: `A → b`, где `A∈Vn` и `b∈(Vt∪Vn)*`.

Распознавателями для КС-языков являются **автоматы с магазинной памятью (МП-автоматы)**.
МП-автомат можно представить в виде семерки `M=(Q,Vt,Vn,F,q0,N0,Z)`, где: 
* `Q` – конечное множество состояний автомата;
* `Vt` – конечный входной алфавит;
* `Vn` – конечный магазинный алфавит;
* `F` – магазинная функция, отображающая множество `(Qx(Vt∪{e})xVn` во множество всех подмножеств множества `QxVn*`, т.е. `F: (Qx(Vt∪{e})xVn) → P(QxVn*)`;
* `q0` – начальное состояние автомата, `q0∈Q`;
* `N0` – начальный символ магазина, `N0∈Vn`;
* `Z` – множество заключительных состояний автомата, `Z∈Q`.

**Конфигурацией МП-автомата** называется тройка вида:
`(q,w,a)∈(QxVt*xVn*)`, где
* `q` - текущее состояние автомата `q∈Q`;
* `w` - часть входной головки, первый символ которой находится под входной головкой, `w∈Vt*`;
* `a` - содержимое магазина, `a∈Vn*`;

#### LL(k)-грамматика

КС-грамматика обладает свойством LL(k) для некоторого k>0, если на каждом шаге вывода для однозначного выбора очередной альтернативы МП-автомату достаточно знать символ на верхушке стека и рассмотреть первые k символов от текущего положения считывающей головки во входной строке.  

КС-грамматика называется **LL(k)-грамматикой**, если она обладает свойством LL(k) для некоторого k>0.
Буквы L в выражении «LL-анализатор» означают, что входная строка анализируется слева направо (left to right), и при этом строится её левосторонний вывод (leftmost derivation).

#### Множества FIRST и FOLLOW

Для построения распознавателей для LL(k)-грамматик используются два множества:
* FIRST(k, a) – множество терминальных цепочек, выводимых из цепочки `a∈(Vt∪Vn)*`, укороченных до k символов;
`FIRST(k,a)={w∈Vt* | ∃ вывод a⇒*w и |w|⩽k или ∃ вывод a⇒*wx и |w|=k; x,a∈(Vt∪Vn)*, k>0}`;
* FOLLOW(k, A) – множество укороченных до k символов терминальных цепочек, которые могут следовать непосредственно за `A∈Vn` в цепочках вывода.
`FOLLOW(k, A)={w∈Vt* | ∃  вывод S⇒*aAy и w∈FIRST(k, y); a,y∈V*, A∈Vn, k>0}`.

#### LL(1)-грамматика

Наибольший интерес в построении синтаксических анализаторов (парсеров) представляют LL(1)-грамматики, так как для них возможно построение нисходящих парсеров без возврата, то есть без корректировки выбранных правил в грамматике. LL(1)-грамматики являются подмножеством КС-грамматик. Однако для достаточно большого количества формальных языков можно построить LL(1)-грамматику, например, для языка арифметических выражений и даже для некоторых языков программирования, в частности можно и для языка Java.

LL(1)-грамматики очень распространены, потому что соответствующие им LL-анализаторы просматривают поток только на один символ вперед при принятии решения о том, какое правило грамматики необходимо применить. Языки, основанные на грамматиках с большим значением k, традиционно считались трудными для распознавания, хотя при широком распространении генераторов синтаксических анализаторов, поддерживающих LL(k) грамматики с произвольным k, это замечание уже неактуально.

#### Необходимое условие для LL(1) грамматики

Для того чтобы грамматика `G(Vn, Vt, P, S)` была LL(1)-грамматикой необходимо и достаточно, чтобы для каждого символа `А∈Vn`, у которого в грамматике существует более одного правила вида `А→a1 | a2 | … | an`, выполнялось требование:
`FIRST(1,aiFOLLOW(1,A))⋂FIRST(1,ajFOLLOW(1, A))=∅,
∀i≠j, 0<i⩽n, 0<j⩽n`.
т.е. если для символа `А` отсутствует правило вида `А→e`, то все множества `FIRST(1,a1)`, `FIRST(1,a2)`, … , `FIRST(1,an)` должны попарно не пересекаться, если же присутствует правило `А→e`, то они не должны также пересекаться с множеством `FOLLOW(1,A)`.
Для построения распознавателей для LL(1)-грамматик необходимо построить множества `FIRST(1,X)` и `FOLLOW(1,A)`. Причем, если строка `х` будет начинаться с терминального символа `а`, то `FIRST(1,x)=a`, и если она будет начинаться с нетерминального символа `А`, то `FIRST(1,x)=FIRST(1,A)`. Следовательно, достаточно рассмотреть алгоритмы построения множеств `FIRST(1,A)` и `FOLLOW(1,A)` для каждого нетерминального символа `А`.
Поскольку в дальнейшем мы рассматриваем только k=1, то будем обозначать `FIRST(1,A)` как `FIRST(A)`, а `FOLLOW(1,A)` как `FOLLOW(A)`


## Практическая часть

#### Постановка задачи

Используя язык программирования Си (стандарт С-99) реализовать алгоритм LL(1) анализатора для формальной грамматики вида:  
   `S=B"2"`  
   `B="0"|"1"`  
Необходимо реализовать функции построения наборов FIRST, FOLLOW и таблицы с выводом их в лог файл.

#### Структура программы

Программа будет состоять из слудующих частей:
1.  Блок Str включает в себя структуру символьных множеств и операции над этой структурой. Блок разработан для упрощения реализации алгоритмов LL(1) анализатора (вставка элемента в множество, поиск удаление и т.п.)  
Данный блок реализован в файлах str.h и str.c
2. Блок Stact включает в себя реализацию стека символов и операций над ним. Стек необходим для функционирования парсера строки и ответа на вопрос, принадлежит ли та или иная строка данной грамматике.  
Данный блок реализован в файлах stack.h и stack.c
3. Блок Grammar является "сердцем" анализатора. От в ключает в себя реализацию структуры, описывающий ипользуемую грамматику языка, поиск FIRST, FOLLOW, конструирование таблицы, запись их в логические файлы и реализацию парсинга строки.  
Данный блок реализован в файлах grammar.h и grammar.c
4. Блок main необходим для аботы самой программы. Через данный блок проходит инициализация грамматики, запуск основных алгоритмов анализатора а также взаимодействие с пользователем: ввод анализируемой строки и вывод информации о используемой грамматики (в частности ее множества FIRST, FOLLOW и предсказывающей таблицы).  
Блок main описан в файле main.c.

Все заголовочные файлы находятся в папке include. Файлы с исходным кодом (кроме main.c) находятся в папке crt. main.c находится в корне репозитория.  
При компиляции программы предполагается, что именно в таком расположении будут находится части программы.

#### Описание работы программы

Программа работает в следующем порядке:
1. *Инициализация полей грамматики*.   
Структура Grammar может быть использована для любой KC-грамматики, соответствующей правилу LL(1). Поэтому прежде чем выполнять парсинг строки необходимо заполнить информацию о самой грамматике, с которой ведется работа.  
Поскольку грамматика, представленая в качестве примера при описании задачи, достаточно простая и не рассматривает всех возможных случаев работы алгоритма, помимо нее я работала с другими грамматиками, которые были найдены мной в учебниках и примерах с полным разбором работы основных алгоритмов для них:  
  Грамматика `G=({S,T,R}, {+,-,(,),a,b}, P, S)`, с правилами P: 1) `S=TR`; 2) `R=e|+TR|-TR`; 3) `T=(S)|a|b`  
  Грамматика `G=({E,A,T,D,F}, {i,+,*,(,)}, P, E)`, с правилами P: 1) `E=TA`; 2) `A=+TA|e`; 3) `T=FD`; 4) `D=*FD|e` 5)`F=(E)|i`  
В результатах работы программы быдет представлены скриншоты командной строки для всех используемых грамматик.  
В коде программы также показаны варианты реализации всех используемых грамматик. При этом инициализации выбранных мной грамматик закоментированы, а инициализация предлагаемой грамматики - нет. Поэтому по-умолчанию будет выполняться работа с грамматикой, описаной в задании.
2. Нахождение FIRST грамматики.  
После инициализации запускается функция из блока Grammar, которая высчитывает FIRST используемой грамматики и сохраняет его в специально выделенную память в структуре трамматики. 
3. Нахождение FOLLOW грамматики  
Запуск поиска FOLLOW происходит аналогично поиску FIRST.
4. Заполнение предсказывающей таблицы грамматики  
Данная таблица заполняется после нахождения FIRST и FOLLOW грамматики, через отдельную функцию в блоке Grammar.
4. Вывод FIRST, FOLLOW и таблицы на экран  
Для проверки корректности работы программы вся расчитанная информация выводится на экран.
5. Запись в логический файл  
По условию задания, расчитанную информацию надо вывести в логический файл. Для этого используется специальная функция в блоке Grammar.  
Предполагается, что FIRST, FOLLOW и таблицу необходимо записать в разные логические файлы: FIRST.bin, FOLLOW.bin и table.bin соответственно.   
Поскольку точной структуры записи представленно не было, я предположила, что в файлах элементы таблицы разделяется символом табуляции (\t)
6. Взаимодействие с пользователем  
На этом этопа попросим пользователя ввести строку, которую необходимо проанализировать. При этом ограничим длину строки в 256 символов для упрощенной реализации считывания из командной строки.
7. Парсинг  
На этом этапе запускается пециальная функция, которая проводит анализ введенной строки по алгоритму "сдвиг-свертка". В резутьтате на экране будет выведена последовательность разбора данной строки и информация о принадлежности этой строки данной грамматики.  
Выполнение частей программы отмечено в файле main.с помощью комментариев.

Описание всех используемых алгоритмов находятся ниже.

#### Алгоритм построения множества FIRST(A)

Построим множество `FIRST(A)` КС-грамматики `G`, не содержащей e-правил:
1. Первоначально внесем во множество первых символов для каждого нетерминального символа `А` все символы, стоящие в начале правых частей правил для этого нетерминала, т.е.
`∀А∈Vn FIRST0(A)={X | (A,Xa)∈P, X∈(Vt∪Vn), a∈(Vt∪Vn)*}`.
2. Для всех `А∈Vn` положим:
`FIRSTi+1(A)=FIRSTi(A)∪FIRSTi(B), ∀В∈(FIRST(A)⋂Vn)`.
3. Если существует `А∈Vn`, такой что `FIRSTi+1(A)≠FIRSTi(A)`, то присвоим `i=i+1` и вернемся к шагу 2, иначе перейдем к шагу 4.
4. Исключим из построенных множеств все нетерминальные символы, т.е.
`∀A∈Vn FIRST(A)=FIRSTi(A)\N`.

#### Алгоритм построения множества FOLLOW(A)

Построим множество `FOLLOW(A)` LL(1)-грамматики `G`:
1. Первоначально внесем во множество последующих символов для каждого нетерминального символа `А` все символы, которые в правых частях правил вывода встречаются непосредственно за символом `А`, т.е.
`∀A∈Vn FOLLOW0(A)={X | ∃(B,aAXb)∈P, B∈Vn, X∈(Vt∪Vn),
a,b∈(Vt∪Vn)*}`.
2. Внесем пустую строку во множество `FOLLOW(S)`, т.е.
`FOLLOW(S) = FOLLOW(S)∪{e}`.
3. Для всех `А∈Vn` вычислим:
`FOLLOW'i(A)=FOLLOWi(A)∪FIRST(B), ∀B∈(FOLLOWi(A)⋂Vn)`.
4. Для всех `А∈Vn` положим:
`FOLLOW²i(A)=FOLLOW'i(A)∪FOLLOW'i(B), ∀B∈(FOLLOW'i(A)⋂Vn)`, если ∃ правило `B→e`
5. Для всех `А∈Vn` определим:
`FOLLOWi+1(A)=FOLLOW²i(A)∪FOLLOW²i(B)`, для всех нетерминальных символов `B∈Vn`, имеющих правило вида
`B→aA, a∈(Vt∪Vn)*`.
6. Если существует `A∈Vn` такой, что `FOLLOWi+1(A)≠FOLLOWi(A)`, то положить `i:=i+1` и вернуться к шагу 3, иначе перейти к шагу 7.
7. Исключить из построенных множеств все нетерминальные символы, т.е. `∀A∈Vn FOLLOW(A)=FOLLOWi(A)\N`.

#### Алгоритм конструирования таблицы предсказывающего анализатора

Для конструирования таблицы предсказывающего анализатора по грамматике `G` может быть использован алгоритм, основанный на следующей идее. Предположим, что `A→a` - правило вывода грамматики и `a∈FIRST(R)`. Тогда анализатор делает развертку `A` по `a`, если входным символом является `a`. Трудность возникает, когда `a=e` или `a⇒*e`. В этом случае нужно развернуть `A` в `a`, если текущий входной символ принадлежит `FOLLOW(A)` или если достигнут `$` и `$∈FOLLOW(A)`. (`$` - это маркер окончания строки)

Последовательность шагов для получения из КС-грамматики `G=(Vn,Vt,P,S)` двумерной таблицы `M[A;a]` предсказывающего анализатора где, `A∈Vn`, `a∈Vt∪{$}`  
Для каждого правила вывода `A→ya`грамматики выполним шаги 1 и 2. После этого выполним шаг 3.
1. Для каждого терминала `a` из `FIRST(R)` добавить `A→R` к  `M[A;a]`.
2. Если `e→FIRST(R)`, добавить `A→R` к `M[A;b]` для каждого терминала `b` из `FOLLOW(A)`. Кроме того, если `e→FIRST(R)` и `$→FOLLOW(A)`, добавить `A→a` к `M[A;$]`.
3. Положить все неопределенные входы равными "ошибка".

#### Алгоритм «сдвиг-свертка» для LL(1)-грамматик

В результате этого алгоритма мы получим порядок выводимости цепочек для конкретной строки. Данный алгоритм выполняется МП-автоматом с использованием стека.
1. Помещаем в стек начальный символ грамматики `S`, а во входной буфер исходную цепочку символов.
2. До тех пор пока в стеке и во входном буфере останется только пустая строка e либо будет обнаружена ошибка в алгоритме разбора, выполняем одно из следующих действий:
2.1. Если на верхушке стека находится нетерминальный символ `А` и очередной символ входной строки символ `а`, то выполняем операцию «свертка» по правилу `А→х `при условии, что `а∈FIRST(1,x)`, т.е. извлекаем из стека символ `А` и заносим в стек строку `х`, не меняя содержимого входного буфера;  
Поскольку мы используем предсказывающую таблицу, мы можем получить X из M[A,a].  
2.2. Если на верхушке стека находится нетерминальный символ `А` и очередной символ входной строки символ `а`, то выполняем операцию «свертка» по правилу `А→e` при условии, что `а∈FOLLOW(1,A)`, т.е. извлекаем из стека символ `А` и заносим в стек строку `e`, не меняя содержимого входного буфера;  
Поскольку мы используем предсказывающую таблицу, мы можем получить X из M[A,a].  
2.3. Если на верхушке стека находится терминальный символ `а`, совпадающий с очередным символом входной строки, то выполняем операцию «выброс», т.е. удаляем из стека и входного буфера данный терминальный символ;
2.4. Если содержимое стека и входного буфера пусто, то исходная строка прочитана полностью, и разбор завершен удачно;
2.5 Если ни одно из данных условий не выполнено, то цепочка не принадлежит заданному языку, и алгоритм завершает свою работу с ошибкой.

#### Результаты работы программы

В результате работы программы из грамматики были получены множества FIRST, FOLLOW и предсказывающая таблица, а так же проаналезирована строка на принадлежность этой грамматике.
* Грамматика из условий задания:
![alt-текст](https://github.com/Imadzuma/Grammar_Analisator/blob/master/Results/Grammar0-true.png?raw=true "Верная строка")
![alt-текст](https://github.com/Imadzuma/Grammar_Analisator/blob/master/Results/Grammar0-false.png?raw=true "Неверная строка")
* Первый пример грамматики:
![alt-текст](https://github.com/Imadzuma/Grammar_Analisator/blob/master/Results/Grammar1-true.png?raw=true "Верная строка")
![alt-текст](https://github.com/Imadzuma/Grammar_Analisator/blob/master/Results/Grammar1-false.png?raw=true "Неверная строка")
* Второй пример грамматики:
![alt-текст](https://github.com/Imadzuma/Grammar_Analisator/blob/master/Results/Grammar2-true.png?raw=true "Верная строка")
![alt-текст](https://github.com/Imadzuma/Grammar_Analisator/blob/master/Results/Grammar2-false.png?raw=true "Неверная строка")

#### Возможные пути для оптимизации

Данная реализация написана с целью обучения и не является самой оптимальной.  
При программировании задачи у меня возникало много идей для ускорения и модернизации алгоритмов, однако не все они были введены, поскольку они нагружают код и затрачивают достаточно времени на разработку, а задача может быть выполнена и без них.
Вот список некоторых:
1. Возможно вместо использования блока Str можно было применять битовые поля. Это бы уменьшило количество перепаковок памяти в случаях добавления и удаления элементов из множеств. Кроме того, это бы сделало размер каждого множества фиксированым - 32 байта для множества элементов типа char, благодаря чему можно отказаться от некоторых переменных (которые хрянят размер множеств).
2. Как вариант, вместо элементы внутри множеств можно упорядочивать, это бы уменьшило время, затрачиваемое на поиск элементов, который применяется достаточно часто.
3. При больших размерах множеств терминалов и нетерминалов можно было использовать хэш-таблицы, которые бы также сократили время нахождения элемена в множестве.
4. Анализируемую грамматику можно также запрашивать у пользователя. Это бы упростило проверку алгоритмов на ошибки и позволило расчитывать информацию из грамматики даже базовому пользователю.
5. Изходя из 4 пункта вытекает следующий. Поскольку не всякая грамматика является КС-грамматикой и тем более не всякая является LL(1) анализатором, то целесообразно сделать проверку самой грамматики. Это бы ликвидировало ошибки при объявлении грамматики не только через командную строку (согласно п.4), но и через исходный код тоже. При программировании у меня возникали ошибки, связанные с неправильным набором парамметров при инициализации грамматики, в результате расчет хараектеристик и парсинг оказывался неверным. 
6. В целом сами блоки использовать для отдельных программ не рукомендуется, потому что в них не существует проверки на тк называемого "глупого пользователя". Так например, функции блока Grammar должны быть вызваны в определенном порядке для корректной работы (так например FOLLOW вычисляется через FIRST в том числе, поэтому не может быть расчитан раньше него). Поэтому целесообразно было бы проверять структуры на наличие той или иной информации.

## Результаты исследования

LL(k) - грамматика тесно связана с нисходящими анализаторами, и обладает следующими особенностями:
1. Они могут быть проанализированы без возвратов;
2. Входная цепочка просматривается слева-направо;
3. Строится левый вывод цепочки.

В целом LL(k)-анализаторы очерь распространнены, потому что такой анализатор легко может быть написан вручную и оптимизирован.  
С другой стороны, восходящие анализаторы могут анализировать большее количество грамматик, чем нисходящие, и поэтому именно для таких методов существуют программы, которые умеют автоматически строить анализаторы. Так, с помощью LR-грамматик можно определить большинство использующихся в настоящее время языков программирования. Поэтому при программировании LL(k)-анализатора следует учитывать, что грамматика имеет существенные ограничения (которые выходят непосредственно из определения). 




